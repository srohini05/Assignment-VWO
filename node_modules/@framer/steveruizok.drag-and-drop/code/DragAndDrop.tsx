import * as React from 'react'
import {
	PropertyControls,
	ControlType,
	FrameProperties,
	serverURL,
} from 'framer'
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd'

interface Props extends FrameProperties {
	items: any[]
	onItemsAddedOrRemoved: (items: any[]) => any
	onBeforeDragStart: (items: any[], props: any) => any
	onDragStart: (items: any[], props: any) => any
	onDragUpdate: (items: any[], props: any) => any
	onDragEnd: (items: any[], props: any) => any
	getListStyle: ListStyleFuncton
	getItemStyle: GetItemStyleFunction
	stretch: boolean
	direction: string
	gap: number
	padding: number
	paddingPerSide: boolean
	paddingTop: number
	paddingRight: number
	paddingLeft: number
	paddingBottom: number
}

interface DraggableItem {
	id: string
	content: any
}

type GetItemStyleFunction = (
	isDragging: boolean,
	draggableStyle: any,
	props: Props
) => React.CSSProperties

type ListStyleFuncton = (
	isDraggingOver: boolean,
	props: Props
) => React.CSSProperties

/**
 * @description A function to set an item's style, depending on its dragging state. Can be overridden!
 * @param {boolean} isDragging
 * @param {*} draggableStyle
 * @param {Props} props
 */
const getItemStyle: GetItemStyleFunction = (
	isDragging: boolean,
	draggableStyle: any,
	props: Props
) => ({
	userSelect: 'none',
	boxShadow: isDragging ? '0 5px 5px 5px rgba(0,0,0,.2)' : 'none',
	...draggableStyle,
})

/**
 * @description A function to set the list style, depending on the dragging state. Can be overridden!
 * @param {boolean} isDraggingOver
 * @param {Props} props
 * @returns
 */
const getListStyle: ListStyleFuncton = (
	isDraggingOver: boolean,
	props: Props
) => {
	const {
		gap,
		paddingPerSide,
		padding,
		paddingTop,
		paddingRight,
		paddingBottom,
		paddingLeft,
		direction,
	} = props

	return {
		display: 'grid',
		gridAutoFlow: direction === 'horizontal' ? 'column' : 'row',
		justifyItems: 'center',
		alignItems: 'center',
		gridAutoRows: 'min-content',
		gridAutoColumns: 'min-content',
		gridGap: gap,
		padding: paddingPerSide
			? [paddingTop, paddingRight, paddingBottom, paddingLeft].join('px ') +
			  'px'
			: padding,
	}
}

/**
 * @description a little function to help us with reordering the result
 * @param {any[]} list
 * @param {number} startIndex
 * @param {number} endIndex
 * @returns
 */
const reorder = (list: any[], startIndex: number, endIndex: number) => {
	const result = Array.from(list)
	const [removed] = result.splice(startIndex, 1)
	result.splice(endIndex, 0, removed)

	return result
}

/**
 * @description Default content, shown when a component has no connected frames
 * @returns
 */
const DefaultContent = () => {
	return (
		<div
			style={{
				height: '100%',
				display: 'grid',
				gridTemplateRows: '1fr min-content min-content min-content 1fr',
				gridGap: '8px',
				alignItems: 'center',
				color: '#8855FF',
				padding: '0 16px',
				background: 'rgba(136, 85, 255, 0.1)',
				overflow: 'hidden',
				flexDirection: 'column',
			}}
		>
			<div>
				<p style={{ fontSize: '20px' }}>
					<b>Drag and Drop</b>
				</p>
				<p>
					Need help getting started? Check out
					<a
						style={{ color: '#029aff' }}
						href="https://store.framer.com/package/steveruizok/drag-and-drop"
					>
						the docs!
					</a>
				</p>
			</div>
		</div>
	)
}

/* ========================================================================== */
/*                                  COMPONENT                                 */
/* ========================================================================== */

export class DragAndDrop extends React.Component<Props> {
	containerRef: React.RefObject<HTMLDivElement> = React.createRef()

	state = {
		offset: { x: 0, y: 0 },
		items: [],
		windowScale: 1,
	}

	static defaultProps = {
		onItemsAddedOrRemoved: () => null,
		onDragStart: () => null,
		onDragEnd: () => null,
		onBeforeDragStart: () => null,
		onDragUpdate: () => null,
		getListStyle: getListStyle,
		getItemStyle: getItemStyle,
		padding: 0,
		direction: 'vertical',
		stretch: false,
		gap: 8,
	}

	static propertyControls: PropertyControls = {
		items: {
			type: ControlType.Array,
			title: 'Items',
			propertyControl: { type: ControlType.ComponentInstance },
		},
		stretch: {
			type: ControlType.Boolean,
			title: 'Stretch',
			defaultValue: false,
		},
		gap: {
			type: ControlType.Number,
			title: 'Gap',
			defaultValue: 8,
		},
		direction: {
			type: ControlType.SegmentedEnum,
			options: ['horizontal', 'vertical'],
			title: 'Direction',
			defaultValue: 'vertical',
		},
		padding: {
			type: ControlType.FusedNumber,
			toggleKey: 'paddingPerSide',
			toggleTitles: ['Padding', 'Padding per side'],
			valueKeys: ['paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
			valueLabels: ['t', 'r', 'b', 'l'],
			min: 0,
			title: 'Padding',
			defaultValue: 0,
		},
	}

	setDraggableItems = (props: any, items: any[]) => {
		const container = this.containerRef.current
		const offset = container.getBoundingClientRect()
		const windowScale = offset.height / props.height

		let {
			stretch,
			width: containerWidth,
			height: containerHeight,
			padding,
			paddingPerSide,
			paddingTop,
			paddingRight,
			paddingBottom,
			paddingLeft,
			direction,
		} = props

		containerWidth = paddingPerSide
			? containerWidth - paddingRight - paddingLeft
			: containerWidth - padding * 2

		containerHeight = paddingPerSide
			? containerHeight - paddingTop - paddingBottom
			: containerHeight - padding * 2

		items = items.map((frame: any, index: number) => {
			const { width: frameWidth, height: frameHeight } = frame.props

			let width =
				direction === 'vertical' && stretch ? containerWidth : frameWidth

			let height =
				direction === 'horizontal' && stretch ? containerHeight : frameHeight

			const cloned = React.cloneElement(frame, {
				top: 0,
				left: 0,
				width,
				height,
			})
			return {
				id: `${index}_${frame.props.id}_cloned`,
				content: (
					<div
						style={{
							display: 'flex',
							alignItems: 'center',
							justifyContent: 'center',
							width: width,
							height: height,
							backgroundColor: 'green',
							position: 'relative',
						}}
					>
						{cloned}
					</div>
				),
			}
		})

		this.setState({ items, offset, windowScale }, () =>
			this.props.onItemsAddedOrRemoved(this.state.items)
		)
	}

	componentDidMount() {
		const { items } = this.props
		this.setDraggableItems(this.props, items)
	}

	componentWillReceiveProps(props: Props) {
		const isCanvasOrPreview = (source: any) => {
			const searchLoop: (node: any) => 'canvas' | 'preview' = node => {
				if (!node) return 'canvas'
				if (node.key === 'preview') return 'preview'
				return searchLoop(node._debugOwner)
			}

			return searchLoop(source._reactInternalFiber)
		}

		if (isCanvasOrPreview(this) === 'preview') return

		let { items } = props
		this.setDraggableItems(props, items)
	}

	onBeforeDragStart = (args: any) => {
		this.props.onBeforeDragStart(this.state.items, args)
	}

	onDragStart = (args: any) => {
		this.props.onDragStart(this.state.items, args)
	}
	onDragUpdate = (args: any) => {
		this.props.onDragUpdate(this.state.items, args)
	}

	onDragEnd = (result: any) => {
		if (!result.destination) return

		const items = reorder(
			this.state.items,
			result.source.index,
			result.destination.index
		)

		this.setState({ items }, () =>
			this.props.onDragEnd(this.state.items, result)
		)
	}

	render() {
		const { getListStyle, direction } = this.props
		const { items } = this.state

		return (
			<div
				ref={this.containerRef}
				style={{
					height: '100%',
					width: '100%',
					display: 'flex',
					justifyContent: direction === 'vertical' ? 'center' : 'flex-start',
					alignItems: direction === 'horizontal' ? 'center' : 'flex-start',
				}}
			>
				{items.length === 0 ? (
					<DefaultContent />
				) : (
					<DragDropContext
						onDragStart={this.onDragStart}
						onDragUpdate={this.onDragUpdate}
						onBeforeDragStart={this.onBeforeDragStart}
						onDragEnd={this.onDragEnd}
					>
						<Droppable droppableId="droppable" direction={direction}>
							{(provided, snapshot) => (
								<div
									ref={provided.innerRef}
									style={{
										...getListStyle(provided.isDraggingOver, this.props),
									}}
								>
									{items.map((item: DraggableItem, index: number) => (
										<Draggable
											key={item.id}
											draggableId={`draggable_${item.id}`}
											index={index}
										>
											{(provided: any, snapshot: any) => {
												if (snapshot.isDragging) {
													if (this.props.direction === 'vertical') {
														provided.draggableProps.style.left -= this.state.offset.x
														provided.draggableProps.style.top -=
															this.state.offset.y * this.state.windowScale
													} else {
														provided.draggableProps.style.left -= this.state.offset.x
														provided.draggableProps.style.top -= this.state.offset.y
													}
												}
												return (
													<div
														ref={provided.innerRef}
														{...provided.draggableProps}
														{...provided.dragHandleProps}
														style={{
															...this.props.getItemStyle(
																snapshot.isDragging,
																provided.draggableProps.style,
																this.props
															),
															margin: 0,
															width: item.content.props.width,
															height: item.content.props.height,
														}}
													>
														{item.content}
													</div>
												)
											}}
										</Draggable>
									))}
									{provided.placeholder}
								</div>
							)}
						</Droppable>
					</DragDropContext>
				)}
			</div>
		)
	}
}
