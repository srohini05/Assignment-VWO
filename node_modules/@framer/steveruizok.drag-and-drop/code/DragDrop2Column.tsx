import * as React from 'react'
import { PropertyControls, ControlType, FrameProperties } from 'framer'
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd'

interface Props extends FrameProperties {
	items1: any[]
	items2: any[]
	template: string
	getListStyle: ListStyleFuncton
	getItemStyle: GetItemStyleFunction
	stretch: boolean
	direction: string
	gap: number
	padding: number
	paddingPerSide: boolean
	paddingTop: number
	paddingRight: number
	paddingLeft: number
	paddingBottom: number
	onItemsAddedOrRemoved: (items: any[]) => any
	onBeforeDragStart: (items: any[], props: any) => any
	onDragStart: (items: any[], props: any) => any
	onDragUpdate: (items: any[], props: any) => any
	onDragEnd: (items: any[], props: any) => any
}

interface DraggableItem {
	id: string
	content: any
}

type GetItemStyleFunction = (
	isDragging: boolean,
	draggableStyle: any
) => React.CSSProperties

type ListStyleFuncton = (
	isDraggingOver: boolean,
	props: Props
) => React.CSSProperties

/**
 * @description A function to set an item's style, depending on its dragging state. Can be overridden!
 * @param {boolean} isDragging
 * @param {*} draggableStyle
 * @param {Props} props
 */
const getItemStyle: GetItemStyleFunction = (
	isDragging: boolean,
	draggableStyle: any
) => ({
	userSelect: 'none',
	boxShadow: isDragging ? '0 5px 5px 5px rgba(0,0,0,.2)' : 'none',
	...draggableStyle,
})

/**
 * @description A function to set the list style, depending on the dragging state. Can be overridden!
 * @param {boolean} isDraggingOver
 * @param {Props} props
 * @returns
 */
const getListStyle: ListStyleFuncton = (
	isDraggingOver: boolean,
	props: Props
) => {
	const {
		gap,
		paddingPerSide,
		padding,
		paddingTop,
		paddingRight,
		paddingBottom,
		paddingLeft,
		direction,
	} = props

	return {
		display: 'grid',
		gridAutoFlow: direction === 'horizontal' ? 'column' : 'row',
		justifyItems: 'center',
		alignItems: 'center',
		gridAutoRows: 'min-content',
		gridAutoColumns: 'min-content',
		gridGap: gap,
		padding: paddingPerSide
			? [paddingTop, paddingRight, paddingBottom, paddingLeft].join('px ') +
			  'px'
			: padding,
	}
}

/**
 * Moves an item from one list to another list.
 */
const move = (
	source: any,
	destination: any,
	droppableSource: any,
	droppableDestination: any
) => {
	const sourceClone = Array.from(source)
	const destClone = Array.from(destination)
	const [removed] = sourceClone.splice(droppableSource.index, 1)

	destClone.splice(droppableDestination.index, 0, removed)

	const result = {}
	result[droppableSource.droppableId] = sourceClone
	result[droppableDestination.droppableId] = destClone

	return result
}

/**
 * @description a little function to help us with reordering the result
 * @param {any[]} list
 * @param {number} startIndex
 * @param {number} endIndex
 * @returns
 */
const reorder = (list: any[], startIndex: number, endIndex: number) => {
	const result = Array.from(list)
	const [removed] = result.splice(startIndex, 1)
	result.splice(endIndex, 0, removed)

	return result
}

/**
 * @description Default content, shown when a component has no connected frames
 * @returns
 */
const DefaultContent = () => {
	return (
		<div
			style={{
				height: '100%',
				display: 'grid',
				gridTemplateRows: '1fr min-content min-content min-content 1fr',
				gridGap: '8px',
				alignItems: 'center',
				color: '#8855FF',
				padding: '0 16px',
				background: 'rgba(136, 85, 255, 0.1)',
				overflow: 'hidden',
				flexDirection: 'column',
				gridColumnStart: 0,
				gridColumnEnd: 4,
			}}
		>
			<div>Connect your child frames</div>
		</div>
	)
}

interface DroppableItem {
	id: string
	ref: React.RefObject<HTMLDivElement>
	items: any[]
	offset: ClientRect | DOMRect | null
}

type UpdateDroppable = (
	droppable: DroppableItem,
	index: number
) => DroppableItem

/* ========================================================================== */
/*                                  COMPONENT                                 */
/* ========================================================================== */

export class DragDrop2Column extends React.Component<Props> {
	containerRef: React.RefObject<HTMLDivElement> = React.createRef()
	droppableRefs: React.RefObject<HTMLDivElement>[] = [
		React.createRef(),
		React.createRef(),
	]

	state = {
		offset: { x: 0, y: 0 },
		droppables: [
			{
				id: 'droppables1',
				ref: React.createRef(),
				items: [],
				offset: null,
			},
			{
				id: 'droppables2',
				ref: React.createRef(),
				items: [],
				offset: null,
			},
		],
		selected: {},
		items: [],
	}

	static defaultProps = {
		onItemsAddedOrRemoved: () => null,
		onDragStart: () => null,
		onDragEnd: () => null,
		onBeforeDragStart: () => null,
		onDragUpdate: () => null,
		getListStyle: getListStyle,
		getItemStyle: getItemStyle,
		padding: 0,
		direction: 'vertical',
		stretch: false,
		gap: 8,
		items1: [],
		items2: [],
	}

	static propertyControls: PropertyControls = {
		template: {
			type: ControlType.String,
			title: 'Template',
			defaultValue: '1fr 1fr',
		},
		items1: {
			type: ControlType.Array,
			title: 'Items 1',
			propertyControl: { type: ControlType.ComponentInstance },
		},
		items2: {
			type: ControlType.Array,
			title: 'Items 2',
			propertyControl: { type: ControlType.ComponentInstance },
		},
		stretch: {
			type: ControlType.Boolean,
			title: 'Stretch',
			defaultValue: false,
		},
		gap: {
			type: ControlType.Number,
			title: 'Gap',
			defaultValue: 8,
		},
		direction: {
			type: ControlType.SegmentedEnum,
			options: ['horizontal', 'vertical'],
			title: 'Direction',
			defaultValue: 'vertical',
		},
		padding: {
			type: ControlType.FusedNumber,
			toggleKey: 'paddingPerSide',
			toggleTitles: ['Padding', 'Padding per side'],
			valueKeys: ['paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
			valueLabels: ['t', 'r', 'b', 'l'],
			min: 0,
			title: 'Padding',
			defaultValue: 0,
		},
	}

	setDroppables = (props: any) => {
		const container = this.containerRef.current
		const offset = container.getBoundingClientRect()

		const { items1, items2 } = props
		const itemsArr = [items1, items2]
		let droppables = this.state.droppables as DroppableItem[]

		const getDroppable: UpdateDroppable = (
			droppable: DroppableItem,
			index: number
		) => {
			const items = this.getItems(props, itemsArr[index])

			return {
				...droppable,
				items,
			}
		}

		droppables = droppables.map(getDroppable)

		this.setState({
			droppables,
			offset,
		})
	}

	getItems = (props: any, items: any[]) => {
		let {
			stretch,
			width: containerWidth,
			height: containerHeight,
			padding,
			paddingPerSide,
			paddingTop,
			paddingRight,
			paddingBottom,
			paddingLeft,
			direction,
		} = props

		containerWidth = paddingPerSide
			? containerWidth - paddingRight - paddingLeft
			: containerWidth - padding * 2

		containerHeight = paddingPerSide
			? containerHeight - paddingTop - paddingBottom
			: containerHeight - padding * 2

		items = items.map((frame: any, index: number) => {
			const { width: frameWidth, height: frameHeight } = frame.props

			let width =
				direction === 'vertical' && stretch ? containerWidth / 2 : frameWidth

			let height =
				direction === 'horizontal' && stretch
					? containerHeight / 2
					: frameHeight

			const cloned = React.cloneElement(frame, {
				top: 0,
				left: 0,
				width,
				height,
			})
			return {
				id: `${index}_${frame.props.id}_cloned`,
				content: (
					<div
						style={{
							display: 'flex',
							alignItems: 'center',
							justifyContent: 'center',
							width: width,
							height: height,
							backgroundColor: 'green',
							position: 'relative',
						}}
					>
						{cloned}
					</div>
				),
			}
		})

		return items
	}

	componentDidMount() {
		this.setDroppables(this.props)
	}

	componentWillReceiveProps(props) {
		const isCanvasOrPreview = (source: any) => {
			const searchLoop: (node: any) => 'canvas' | 'preview' = node => {
				if (!node) return 'canvas'
				if (node.key === 'preview') return 'preview'
				return searchLoop(node._debugOwner)
			}

			return searchLoop(source._reactInternalFiber)
		}

		if (isCanvasOrPreview(this) === 'preview') return
		this.setDroppables(props)
	}

	onBeforeDragStart = (args: any) => {
		this.props.onBeforeDragStart(this.state.items, args)
	}

	onDragStart = (args: any) => {
		this.props.onDragStart(this.state.items, args)
	}
	onDragUpdate = (args: any) => {
		this.props.onDragUpdate(this.state.items, args)
	}

	getDroppable = (id: string) =>
		this.state.droppables.find(
			(droppable: DroppableItem) => droppable.id === id
		)

	onDragEnd = (result: any) => {
		const { droppables } = this.state
		const { source, destination } = result

		if (!destination) return

		if (source.droppableId === destination.droppableId) {
			const droppable = this.getDroppable(source.droppableId)

			droppable.items = reorder(
				droppable.items,
				source.index,
				destination.index
			)

			this.setState({
				droppables,
			})
		} else {
			const sourceDroppable = this.getDroppable(source.droppableId)
			const destinationDroppable = this.getDroppable(destination.droppableId)

			const result: any = move(
				sourceDroppable.items,
				destinationDroppable.items,
				source,
				destination
			)

			sourceDroppable.items = result[source.droppableId]
			destinationDroppable.items = result[destination.droppableId]

			this.setState({
				droppables,
			})
		}
	}

	render() {
		const { getListStyle, getItemStyle, template } = this.props
		const { droppables, offset } = this.state

		return (
			<div
				ref={this.containerRef}
				style={{
					height: '100%',
					width: '100%',
					display: 'grid',
					gridTemplateColumns: template,
				}}
			>
				{droppables[0].items.concat(droppables[1].items).length === 0 ? (
					<DefaultContent />
				) : (
					<DragDropContext
						onDragStart={this.onDragStart}
						onDragUpdate={this.onDragUpdate}
						onBeforeDragStart={this.onBeforeDragStart}
						onDragEnd={this.onDragEnd}
					>
						{droppables.map((droppable: DroppableItem) => {
							return (
								<Droppable
									key={droppable.id + '_droppable'}
									droppableId={droppable.id}
								>
									{(provided, snapshot) => {
										return (
											<div
												key={droppable.id + '_container'}
												ref={droppable.ref}
											>
												<div
													ref={provided.innerRef}
													style={{
														...getListStyle(
															snapshot.isDraggingOver,
															this.props
														),
														width: '100%',
														height: '100%',
													}}
												>
													{droppable.items.map((item, index) => {
														return (
															<Draggable
																key={item.id}
																draggableId={item.id}
																index={index}
															>
																{(provided: any, snapshot: any) => {
																	if (snapshot.isDragging) {
																		provided.draggableProps.style.left -=
																			offset.x
																		provided.draggableProps.style.top -=
																			offset.y
																	}

																	return (
																		<div
																			ref={provided.innerRef}
																			{...provided.draggableProps}
																			{...provided.dragHandleProps}
																			style={{
																				...getItemStyle(
																					snapshot.isDragging,
																					provided.draggableProps.style
																				),
																				margin: 0,
																				width: item.content.props.width,
																				height: item.content.props.height,
																			}}
																		>
																			{item.content}
																		</div>
																	)
																}}
															</Draggable>
														)
													})}
													{provided.placeholder}
												</div>
											</div>
										)
									}}
								</Droppable>
							)
						})}
					</DragDropContext>
				)}
			</div>
		)
	}
}
